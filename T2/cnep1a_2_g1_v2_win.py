# -*- coding: utf-8 -*-
"""CNEP1a_2_G1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NgLopfpfrVfLE0iNOcZSh_nYPORDDoA2
"""

#%%
import ctypes
import multiprocessing
import os
import sys, getopt
import random
import math

import matplotlib.pyplot as plt

## -> Networkx
import networkx as nx
from networkx.readwrite import edgelist
from networkx.algorithms import approximation as approx
from networkx import Graph as gr
## <- Networkx

import itertools

import numpy as np

## -> MultiProcessing
from multiprocessing import *
## <- MultiProcessing

#USAGE INFORMATION
def print_usage():
    print('USAGE: ',os.path.basename(__file__),' -i <inputfile> -t <iterationCount> -v <vertices_to_remove> -e <edges_to_remove>')
    print('        Options:')
    print('            -i : sets input file name relative to script path. E.g. default: ''testdata/urv_email''')
    print('            -t : greedy iteration count (default: vertices^2)');
    print('            -v : number of vertices to remove (default: 2)');
    print('            -t : number of edges to remove (default: 2)');
    print('            -d : debug level (0 - none, 2 - max)')
    
#CONFIGURATION CLASS
class config:
    def __init__(self, input_file, iterCount, iK1, iK2, iDebug):
        self.inputFile = input_file
        self.G = nx.read_adjlist(self.inputFile, nodetype = int)

        #USE IF GRAPHICAL INTERFACE IS PRESENT, AND GRAPH IS NOT TOO BIG
        #plt.subplot(131)
        #nx.draw(self.G, with_labels=True) #, pos=nx.planar_layout(G), node_color='r', edge_color='b')

        # INIT VALUES
        self.K1 = iK1 if (iK1>0) else 2 # vertices to delete
        self.K2 = iK2 if (iK2>0) else 2 # edges to delete
        self.K = self.K1 + self.K2
        self.INF = self.G.number_of_nodes() ** 2
        if iterCount == 0 :
            self.IterationCount = self.G.number_of_nodes() ** 2
        else:
            self.IterationCount = iterCount
        
        self.pool_size = multiprocessing.cpu_count() - 1
        self.NIL = -1  #not defined in NetworkX!!!
        #print extra information
        self.debug = iDebug

#PRINT CONFIGURATION
def print_config(mainConfig):
    print('Current configuration:\n----------------------')
    print('Pool size: ', mainConfig.pool_size)
    print('Inputfile: ', mainConfig.inputFile,'\n')

    print('Graph properties:\n-----------------')
    print("G - edgecount: " + str(len(mainConfig.G.edges)))
    print("G - nodecount: " + str(len(mainConfig.G.nodes)),'\n')

    print('Vertices to delete: ', mainConfig.K1)
    print('   Edges to delete: ', mainConfig.K1)
    print('        Iterations:',mainConfig.IterationCount,'\n')
    print('         Processes:',mainConfig.pool_size,'\n')

#MULTIPROCESSING SETUP
def pool_init(q):
    global que # make queue global in workers
    que = q

#PAIRWISE CONNECTIVITY - using component count
def f_pairwise(lst): ### A komponensek szamossagabol a "pairwise-connectivity"
    summa = sum([len(c)*(len(c)-1)/2 if (len(c)>1) else 0 for c in lst])
    return summa

def h_component(lst): 
    return sum(lst)

#GENERATE RANDOM ELEMENT
def select_random(lst):
    return random.choice(lst)

#GENERATE LIST OF BEST VERTICES AND EDGES
def best_nodes_edges_CNEP1A_Alg2(config,SN,SE, GG): 
    selectedEdges = []
    selectedNodes = []
    min_pw = config.INF
    P = GG.copy()
    P.remove_nodes_from(SN)
    P.remove_edges_from(SE)
    node_f_orig = f_pairwise(nx.connected_components(P))
    SG2 = nx.edges(config.G)
    SG1 = nx.nodes(config.G)
    if (config.iDebug == 2):
        print("--------------------------------------------\nKezdes")
        print("-> S: ", S)
        print("   node_f_orig = ", node_f_orig)
    if len(SN) < config.K1:
        for curr_node in SG1:
            R = P.copy()
            R.remove_nodes_from([curr_node])
            node_f = node_f_orig - f_pairwise(nx.connected_components(R))
            if (config.iDebug == 2):
                print("      node_f = ", node_f," (S: ",set(S)-set([curr_node]),")")

            if node_f < min_pw:
                selectedNodes.clear
                selectedNodes.append(curr_node)
                min_pw = node_f
            elif node_f == min_pw:
                selectedNodes.append(curr_node)

    if len(SE) < config.K2:
         for curr_edge in SG2:
            R = P.copy()
            R.remove_edges_from([curr_edge])
            node_f = node_f_orig - f_pairwise(nx.connected_components(R))
            if (config.iDebug == 2):
                print("      node_f = ", node_f," (S: ",set(S)-set([curr_node]),")")

            if node_f < min_pw:
                selectedEdges.clear
                selectedEdges.append(curr_edge)
                min_pw = node_f
            elif node_f == min_pw:
                selectedEdges.append(curr_edge)
    if (config.iDebug == 2):
        print("->N:",selectedNodes)   
        print("->E:",selectedEdges)   
    return [selectedNodes,selectedEdges]

# CNP1a Alg2 G1
def CNEP1a_2_G1(config):
    S = []
    E = []
    
    H = config.G.copy()
    
    while len(S)+len(E) < config.K:
        [A,B] = best_nodes_edges_CNEP1A_Alg2(config,S,E, H)
        if (config.iDebug == 2):
            print("B: ", B) ###
        z1 = z2 = config.NIL
        if len(A)>0:
            z1 = select_random(A)
            if (config.iDebug == 2):
                print("--> (randN)",z1) ###
        if len(B)>0:
            z2 = select_random(B)
            if (config.iDebug == 2):
                print("--> (randE)",z2) ###

        if (z1!=config.NIL):
            if (z2!=config.NIL):
                if random.randint(0,1) == 1:
                    S.append(z1)
                    H.remove_nodes_from([z1])
                    if (config.iDebug == 2):
                        print("--> (del)N") ###
                else:
                    E.append(z2)
                    H.remove_edges_from([z2])
                    if (config.iDebug == 2):
                        print("--> (del)E") ###
            else:
                S.append(z1)
                H.remove_nodes_from([z1])
                if (config.iDebug == 2):
                    print("--> (del)N") ###
        else:
            E.append(z2)
            H.remove_edges_from([z2])
            if (config.iDebug == 2):
                print("--> (del)E") ###
    
    return [H,S,E]
    
def makeCNEPRun(config,method,i):
    if (config.iDebug > 0):
        #if (i%100 == 0):
        print('Run: ',i,'/',config.IterationCount)
    [R, SS, EE] = method(config)
    if (config.iDebug == 2):
        print(SS)
    currVal = f_pairwise(nx.connected_components(R))
    if (config.iDebug == 2):
        print(currVal)
    que.put([currVal,SS,EE])


if __name__ == '__main__':
    # WINDOWS: this must be in the __main__ section
    def run(pool):
        tasks = []
        for i in range(mainConfig.IterationCount):
            tasks.append(pool.apply_async(makeCNEPRun,args=(mainConfig,CNEP1a_2_G1,i,)))
        for t in tasks:
            t.get()
    
    ### PROCESSING COMMAND LINE ARGUMENTS
    ifile = "testdata/urv_email.txt"
    iterCount = 0
    iK1 = 0
    iK2 = 0
    iDebug = 0
    try:
        opts, args = getopt.getopt(sys.argv[1:],"hi:t:v:e:d")
    except getopt.GetoptError as err:
        print(err)
        print_usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt == "-h":
            print_usage()
            sys.exit()
        elif opt == "-i":
            ifile = arg
        elif opt == "-t":
            iterCount = int(arg)
        elif opt == "-v":
            iK1 = int(arg)
        elif opt == "-e":
            iK2 = int(arg)
        elif opt == "-d":
            iDebug = 1
            

     
    mainConfig = config(ifile, iterCount, iK1, iK2, iDebug)
    print_config(mainConfig)
    
    
    minVal = math.inf
    minR = mainConfig.NIL
    minSS = []
    minEE = []


    method = CNEP1a_2_G1
    plotNo = 111
    minValE = [math.inf,[],[],[]]

    # EXECUTION
    que = Queue()
    pool = Pool(processes=mainConfig.pool_size, initializer=pool_init, initargs=(que,))
    run(pool)
    pool.close()
    #pool.join()
    
    # SEARCHING FOR BEST SOLUTION
    que.put('STOP')
    for i in iter(que.get, 'STOP'):
        if (i[0]<minValE[0]):
            minValE = i

    # UNPACKING BEST SOLUTION
    [minVal,minSS,minEE] = minValE

    
    # PRINTING SOLUTION DETAILS
    minR = mainConfig.G.copy()
    minR.remove_nodes_from(minSS)
    minR.remove_edges_from(minEE)

    print('Modified graph properties:\n-----------------')
    print("Edge count: " + str(len(minR.edges)))
    print("Node count: " + str(len(minR.nodes)),'\n')

    print('  Nodes removed: ',minSS)
    print('  Edges removed: ',minEE)
    print('MinVal achieved: ',minVal)

    # Original and modified graph details
    #print('Original nodes: ',sorted(G.nodes, key=lambda tup: tup[0]))
    #print('Original edges: ',sorted(G.edges, key=lambda tup: tup[0]))
    #print('Modified nodes: ',sorted(minR.nodes, key=lambda tup: tup[0]))
    #print('Modified edges: ',sorted(minR.edges, key=lambda tup: tup[0]))

    ## csak ha van grafikus felulet
    #plt.subplot(plotNo)
    #nx.draw(minR, with_labels=True) #, pos=nx.planar_layout(G), node_color='r', edge_color='b')